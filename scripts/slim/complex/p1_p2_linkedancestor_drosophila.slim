// set up the first simulation
// this is a pulse of migration from population 1 into population 2 
// there is a sweep in the ancestor
// neutral mutations are added after the fact via tree sequence recording


initialize() {
	// initialize tree sequence recording
	initializeTreeSeq();// 

        // draw selection coefficient	
	defineConstant("selcoef", runif(1, minsel, maxsel));
	
	
	// we'll overlay our. neutral mutations, so this is zero.
	initializeMutationRate(0);
	
	// m1 mutation type: beneficial
	initializeMutationType("m3", 1.0, "f", selcoef);
	
	// g1 genomic element type: uses m3 for all mutations
	initializeGenomicElementType("g1", m3, 1.0);
	
	// uniform chromosome of length 10 kb with uniform recombination
	initializeGenomicElement(g1, 0, 9999);
	initializeRecombinationRate(recrate);
}

// create a population of npop individuals and introduce a beneficial mutation
1 early() {
	sim.addSubpop("p1", npop);
	defineConstant("simID", getSeed());


        community.rescheduleScriptBlock(s1, 1, burnin-1);
        community.rescheduleScriptBlock(s2, burnin-1, burnin-1);
        community.rescheduleScriptBlock(s3, burnin, burnin);
	community.rescheduleScriptBlock(s4, asInteger(divtime) - asInteger(tmig)+burnin, asInteger(divtime) - asInteger(tmig)+burnin);
	community.rescheduleScriptBlock(s5, asInteger(divtime) - asInteger(tmig)+burnin + 1, asInteger(divtime) - asInteger(tmig)+burnin + 1);
        community.rescheduleScriptBlock(s6, asInteger(divtime)+burnin, asInteger(divtime)+burnin);

}

1 late() {
	target = sample(p1.genomes, 1);
	target.addNewDrawnMutation(m3, 4999);
	sim.treeSeqOutput("/tmp/"+rep+"slim_" + simID + ".trees");
}



s1 1:1000 late() {
	if (sim.countOfMutationsOfType(m3) == 0) {
		if (sum(sim.substitutions.mutationType == m3) == 1) {
			cat(getSeed() + ": FIXED\n");
			community.deregisterScriptBlock(self);
		} else {
			cat(getSeed() + ": LOST - RESTARTING\n");
			sim.readFromPopulationFile("/tmp/"+rep+"slim_" + simID + ".trees");
			setSeed(rdunif(1, 0, asInteger(2^62) - 1));
		}
	}
}
s2 1000 late(){
	if (sum(sim.substitutions.mutationType == m3) != 1) {
		cat(getSeed() + ": NOT FIXED - RESTARTING\n");
		sim.readFromPopulationFile("/tmp/"+rep+"slim_" + simID + ".trees");
		setSeed(rdunif(1, 0, asInteger(2^62) - 1));
	}
}


// split the two populations
s3 1001 early() {
	sim.addSubpopSplit("p2", npop, p1);
	sim.treeSeqRememberIndividuals(sim.subpopulations.individuals);		
}

// migration pulse
s4 12625 early() {
	p2.setMigrationRates(p1, pmig);
}

s5 12626 early() {
	p2.setMigrationRates(p1, 0);
}

s6 16250 late() {
	cat("Final random seed: " + getSeed() + "\n");
	cat("Selection_coefficient: " + selcoef);
	name = "p1_p2_linkedancestor_drosophila_"+rep+".trees";
	sim.treeSeqOutput(name);
}

